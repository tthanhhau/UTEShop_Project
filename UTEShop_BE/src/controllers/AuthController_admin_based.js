// src/controllers/authController.js - Admin-based email configuration
import User from '../models/user.js';
import Otp from '../models/Otp.js';
import { sendMail, testEmail } from '../config/mailer_admin_based.js';
import { otpHtml } from '../utils/emailTemplates.js';
import generateOtp from '../utils/generateOtp.js';
import { hash, compare } from '../utils/hash.js';
import {
    signToken,
    signRefreshToken,
    verifyRefreshToken,
} from '../services/jwtServices.js';
import { asyncHandler } from '../utils/asyncHandler.js';

/* ----------------------------- Helpers ----------------------------- */

const addMinutes = (d, mins) => new Date(d.getTime() + mins * 60000);

async function createAndSendOtp(email, type, title) {
    try {
        console.log(`üîê Creating OTP for ${email}, type: ${type} (Admin-based email)`);

        // clear OTP c≈© c√πng type
        await Otp.deleteMany({ email, type });

        const code = generateOtp(); // 6 ch·ªØ s·ªë
        const codeHash = await hash(code);
        const expiresAt = addMinutes(new Date(), 10); // 10 ph√∫t

        // L∆∞u OTP v√†o database
        await Otp.create({ email, codeHash, type, expiresAt, attempts: 0 });

        console.log(`üîê Generated OTP for ${email}: ${code}`);

        try {
            // G·ª≠i email v·ªõi admin-based configuration
            await sendMail({
                to: email,
                subject: `${title} ‚Äì M√£ OTP`,
                html: otpHtml({ title, code }),
            });

            console.log(`‚úÖ OTP email sent successfully to ${email} (Admin-based)`);
            return { success: true, message: 'OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i' };
        } catch (emailError) {
            console.error(`‚ùå Failed to send OTP email to ${email} (Admin-based):`, emailError);

            // X√≥a OTP ƒë√£ t·∫°o v√¨ email g·ª≠i th·∫•t b·∫°i
            await Otp.deleteMany({ email, type });

            throw new Error(`Kh√¥ng th·ªÉ g·ª≠i email OTP: ${emailError.message}`);
        }
    } catch (error) {
        console.error('‚ùå Error in createAndSendOtp (Admin-based):', error);
        throw error;
    }
}

/* ---------------------------- Controllers --------------------------- */

// 1) G·ª≠i OTP ƒëƒÉng k√Ω
export const registerRequestOtp = asyncHandler(async (req, res) => {
    const { email } = req.body;

    console.log('üìß Register OTP request for:', email, '(Admin-based email)');

    const exists = await User.findOne({ email }).lean();
    if (exists) {
        console.log('‚ùå Email already exists:', email);
        return res.status(409).json({ message: 'Email ƒë√£ t·ªìn t·∫°i' });
    }

    try {
        await createAndSendOtp(email, 'register', 'X√°c th·ª±c ƒëƒÉng k√Ω');
        return res.json({ message: 'OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n' });
    } catch (error) {
        console.error('‚ùå Register OTP request failed (Admin-based):', error);
        return res.status(500).json({
            message: 'Kh√¥ng th·ªÉ g·ª≠i OTP. Vui l√≤ng th·ª≠ l·∫°i sau.',
            error: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
});

// 2) X√°c minh OTP & t·∫°o t√†i kho·∫£n
export const registerVerify = asyncHandler(async (req, res) => {
    const { email, code, name, password } = req.body;

    console.log('üîç Register verify request for:', email, '(Admin-based email)');

    const otp = await Otp.findOne({ email, type: 'register' });
    if (!otp) {
        console.log('‚ùå OTP not found for:', email);
        return res.status(400).json({ message: 'OTP kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ d√πng' });
    }

    if (otp.expiresAt < new Date()) {
        console.log('‚ùå OTP expired for:', email);
        await Otp.deleteOne({ _id: otp._id });
        return res.status(400).json({ message: 'OTP ƒë√£ h·∫øt h·∫°n' });
    }

    const ok = await compare(code, otp.codeHash);
    if (!ok) {
        otp.attempts = (otp.attempts || 0) + 1;
        await otp.save();
        console.log('‚ùå Invalid OTP for:', email, 'attempts:', otp.attempts);
        return res.status(400).json({ message: 'M√£ OTP kh√¥ng ƒë√∫ng' });
    }

    try {
        // Map name -> username ƒë·ªÉ t∆∞∆°ng th√≠ch schema (k·ªÉ c·∫£ khi b·∫°n ƒë√£ alias)
        const user = await User.create({ email, username: name, password });
        console.log('‚úÖ User created successfully:', email, '(Admin-based email)');

        await Otp.deleteMany({ email, type: 'register' });

        return res.status(201).json({
            message: 'ƒêƒÉng k√Ω th√†nh c√¥ng',
            user: {
                id: user._id,
                email: user.email,
                name: user.name || user.username,
            },
        });
    } catch (createError) {
        console.error('‚ùå Failed to create user (Admin-based):', createError);
        return res.status(500).json({ message: 'ƒêƒÉng k√Ω th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i.' });
    }
});

// 3) G·ª≠i OTP qu√™n m·∫≠t kh·∫©u
export const resetRequestOtp = asyncHandler(async (req, res) => {
    const { email } = req.body;

    console.log('üìß Reset OTP request for:', email, '(Admin-based email)');

    const user = await User.findOne({ email }).lean();
    if (!user) {
        console.log('‚ùå User not found:', email);
        return res.status(404).json({ message: 'Email kh√¥ng t·ªìn t·∫°i' });
    }

    try {
        await createAndSendOtp(email, 'reset', 'ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u');
        return res.json({ message: 'OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n' });
    } catch (error) {
        console.error('‚ùå Reset OTP request failed (Admin-based):', error);
        return res.status(500).json({
            message: 'Kh√¥ng th·ªÉ g·ª≠i OTP. Vui l√≤ng th·ª≠ l·∫°i sau.',
            error: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
});

// 4) X√°c minh OTP & ƒë·ªïi m·∫≠t kh·∫©u
export const resetVerify = asyncHandler(async (req, res) => {
    const { email, code, newPassword } = req.body;

    console.log('üîç Reset verify request for:', email, '(Admin-based email)');

    const otp = await Otp.findOne({ email, type: 'reset' });
    if (!otp) {
        console.log('‚ùå Reset OTP not found for:', email);
        return res.status(400).json({ message: 'OTP kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ d√πng' });
    }

    if (otp.expiresAt < new Date()) {
        console.log('‚ùå Reset OTP expired for:', email);
        await Otp.deleteOne({ _id: otp._id });
        return res.status(400).json({ message: 'OTP ƒë√£ h·∫øt h·∫°n' });
    }

    const ok = await compare(code, otp.codeHash);
    if (!ok) {
        otp.attempts = (otp.attempts || 0) + 1;
        await otp.save();
        console.log('‚ùå Invalid reset OTP for:', email, 'attempts:', otp.attempts);
        return res.status(400).json({ message: 'M√£ OTP kh√¥ng ƒë√∫ng' });
    }

    try {
        const user = await User.findOne({ email });
        if (!user) {
            console.log('‚ùå User not found during reset:', email);
            return res.status(404).json({ message: 'Email kh√¥ng t·ªìn t·∫°i' });
        }

        user.password = newPassword; // pre-save hook s·∫Ω hash
        await user.save();
        console.log('‚úÖ Password reset successfully for:', email, '(Admin-based email)');

        await Otp.deleteMany({ email, type: 'reset' });

        return res.json({ message: 'ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng' });
    } catch (resetError) {
        console.error('‚ùå Password reset failed (Admin-based):', resetError);
        return res.status(500).json({ message: 'ƒê·ªïi m·∫≠t kh·∫©u th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i.' });
    }
});

// 5) ƒêƒÉng nh·∫≠p
export const login = asyncHandler(async (req, res) => {
    console.log('üîê LOGIN - Request body:', req.body, '(Admin-based email)');

    const { email, password } = req.body;
    if (!email || !password) {
        return res.status(400).json({
            message: 'Email & password required',
            code: 'MISSING_CREDENTIALS'
        });
    }

    // T√¨m user theo email
    const user = await User.findOne({ email });
    if (!user) {
        console.log('‚ùå LOGIN - User not found:', email);
        return res.status(401).json({
            message: 'Sai email ',
            code: 'INVALID_CREDENTIALS'
        });
    }

    // Ki·ªÉm tra password
    const ok = await user.comparePassword(password);
    if (!ok) {
        console.log('‚ùå LOGIN - Wrong password for:', email);
        return res.status(401).json({
            message: 'Sai  m·∫≠t kh·∫©u',
            code: 'INVALID_CREDENTIALS'
        });
    }

    // T·∫°o payload cho JWT v·ªõi ƒë·∫ßy ƒë·ªß th√¥ng tin
    const payload = {
        _id: user._id, // S·ª≠ d·ª•ng _id thay v√¨ id ƒë·ªÉ nh·∫•t qu√°n v·ªõi MongoDB
        id: user._id, // Th√™m id ƒë·ªÉ t∆∞∆°ng th√≠ch
        email: user.email,
        name: user.name,
        role: user.role,
        loyaltyPoints: user.loyaltyPoints.balance
    };

    console.log('üîë LOGIN - Creating token with payload:', payload, '(Admin-based email)');

    // T·∫°o tokens
    const token = signToken(payload);
    const refreshToken = signRefreshToken(payload);

    console.log('‚úÖ LOGIN - Login successful for:', email, '(Admin-based email)');

    return res.json({
        token,
        refreshToken,
        user: {
            _id: user._id,
            id: user._id,
            email: user.email,
            name: user.name,
            role: user.role,
            phone: user.phone || '',
            address: user.address || '',
            avatarUrl: user.avatarUrl || ''
        },
        message: 'ƒêƒÉng nh·∫≠p th√†nh c√¥ng'
    });
});

// 6) L·∫•y profile (y√™u c·∫ßu middleware requireAuth set req.user)
export const me = asyncHandler(async (req, res) => {
    const user = await User.findById(req.user.id).select('-password');
    if (!user) return res.status(404).json({ message: 'User kh√¥ng t·ªìn t·∫°i' });
    res.json({ user });
});

// 7) Refresh access token
export const refreshTokenController = asyncHandler(async (req, res) => {
    const { refreshToken } = req.body;
    if (!refreshToken) return res.status(401).json({ message: 'Refresh token required' });

    try {
        const payload = verifyRefreshToken(refreshToken);
        const token = signToken({ id: payload.id, email: payload.email });
        return res.json({ token });
    } catch {
        return res.status(403).json({ message: 'Refresh token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n' });
    }
});

// 8) Logout (n·∫øu b·∫°n l∆∞u refresh token server-side th√¨ xo√° ·ªü ƒë√¢y)
// Hi·ªán t·∫°i kh√¥ng l∆∞u server-side -> ch·ªâ tr·∫£ OK ƒë·ªÉ FE xo√° local
export const logout = asyncHandler(async (_req, res) => {
    res.json({ message: 'Logged out successfully' });
});

// 9) Test email endpoint (ch·ªâ cho development)
export const testEmailEndpoint = asyncHandler(async (req, res) => {
    if (process.env.NODE_ENV !== 'development') {
        return res.status(403).json({ message: 'Test email only available in development' });
    }

    const { email } = req.body;
    if (!email) {
        return res.status(400).json({ message: 'Email is required' });
    }

    try {
        const result = await testEmail(email);
        if (result.success) {
            return res.json({ message: 'Test email sent successfully (Admin-based)' });
        } else {
            return res.status(500).json({
                message: 'Test email failed (Admin-based)',
                error: result.error
            });
        }
    } catch (error) {
        console.error('‚ùå Test email endpoint failed (Admin-based):', error);
        return res.status(500).json({
            message: 'Test email failed (Admin-based)',
            error: error.message
        });
    }
});